#include <iostream>
#include <algorithm>
#include <bitset>
#include <set>
#include <vector>
#include <chrono>
#include <random>
#include <thread>
#include <functional>
#include <numeric>
#include <string>
#include "../../shared/global.cpp"
#include <cstdint>
#include <cstring>
#include <iomanip>

#ifndef TRIVIUM_CIPHER
#define TRIVIUM_CIPHER

int trivium_is_debug_mode = 0; 
typedef uint8_t trivium_ctx_t[36]; /* 288bit */

void trivium_init(const void *trivium_key, uint16_t keysize_b,
                  const void *trivium_iv,  uint16_t ivsize_b,
                  trivium_ctx_t *ctx);

#define G(i) ((((*ctx)[(i)/8])>>(((i)%8)))&1)
#define S(i,v) ((*ctx)[(i)/8] = (((*ctx)[(i)/8]) & (uint8_t)~(1<<((i)%8))) | ((v)<<((i)%8)))

uint8_t trivium_enc(trivium_ctx_t *ctx) {
    uint8_t t1, t2, t3, z;
    
    t1 = G(65)  ^ G(92);
    t2 = G(161) ^ G(176);
    t3 = G(242) ^ G(287);
    z  = t1^t2^t3;
    t1 ^= (G(90)  & G(91))  ^ G(170);
    t2 ^= (G(174) & G(175)) ^ G(263);
    t3 ^= (G(285) & G(286)) ^ G(68);
    
    /* shift whole state and insert ts later */
    uint8_t i, c1 = 0, c2;
    for(i = 0; i < 36; ++i) {
        c2 = (((*ctx)[i]) >> 7);
        (*ctx)[i] = (((*ctx)[i]) << 1) | c1;
        c1 = c2;
    }
    /* insert ts */
    S(0, t3);
    S(93, t1);
    S(177, t2);
    

    return z ? 0x80 : 0x00;
}

uint8_t trivium_getbyte(trivium_ctx_t *ctx) {
    uint8_t r = 0, i = 0;
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_getbyte] Starting byte generation" << std::endl;
    }
    
    do {
        r >>= 1;
        uint8_t enc_bit = trivium_enc(ctx);
        r |= enc_bit;
        
        if(trivium_is_debug_mode) {
            std::cout << "[DEBUG trivium_getbyte] Bit " << (int)i 
                      << ": enc_bit=" << (int)enc_bit 
                      << ", current r=" << std::hex << (int)r << std::dec << std::endl;
        }
    } while(++i < 8);
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_getbyte] Generated byte: " 
                  << std::hex << (int)r << std::dec << std::endl;
    }
    
    return r;
}

#define KEYSIZE_B ((keysize_b+7)/8)
#define IVSIZE_B  ((ivsize_b +7)/8)

static const uint8_t rev_table[16] = {
    0x00, 0x08, 0x04, 0x0C,   /* 0000 1000 0100 1100 */
    0x02, 0x0A, 0x06, 0x0E,   /* 0010 1010 0110 1110 */
    0x01, 0x09, 0x05, 0x0D,   /* 0001 1001 0101 1101 */
    0x03, 0x0B, 0x07, 0x0F    /* 0011 1011 0111 1111 */
};

// Helper function to replace pgm_read_byte
inline uint8_t read_byte(const uint8_t* addr) {
    return *addr;
}

void trivium_init(const void *trivium_key, uint16_t keysize_b,
                  const void *trivium_iv,  uint16_t ivsize_b,
                  trivium_ctx_t *ctx) {
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_init] Initializing with keysize_b=" << keysize_b 
                  << ", ivsize_b=" << ivsize_b << std::endl;
    }
    
    uint16_t i;
    uint8_t c1, c2;
    uint8_t t1, t2;
    memset((*ctx) + KEYSIZE_B, 0, 35 - KEYSIZE_B);
    c2 = 0;
    c1 = KEYSIZE_B;
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_init] Processing trivium_key bytes" << std::endl;
    }
    
    do {
        t1 = ((const uint8_t*)trivium_key)[--c1];
        t2 = (read_byte(&(rev_table[t1 & 0x0f])) << 4) | (read_byte(&(rev_table[t1 >> 4])));
        (*ctx)[c2++] = t2;
        
        if(trivium_is_debug_mode) {
            std::cout << "[DEBUG trivium_init] trivium_Key byte " << (int)c1 
                      << ": original=" << std::hex << (int)t1 
                      << ", reversed=" << (int)t2 << std::dec << std::endl;
        }
    } while(c1 != 0);

    c2 = 12;
    c1 = IVSIZE_B;
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_init] Processing trivium_IV bytes" << std::endl;
    }
    
    do {
        t1 = ((const uint8_t*)trivium_iv)[--c1];
        t2 = (read_byte(&(rev_table[t1 & 0x0f])) << 4) | (read_byte(&(rev_table[t1 >> 4])));
        (*ctx)[c2++] = t2;
        
        if(trivium_is_debug_mode) {
            std::cout << "[DEBUG trivium_init] trivium_IV byte " << (int)c1 
                      << ": original=" << std::hex << (int)t1 
                      << ", reversed=" << (int)t2 << std::dec << std::endl;
        }
    } while(c1 != 0);

    uint8_t shift_temp = 0;
    for(i = 12 + IVSIZE_B; i > 10; --i) {
        c2 = (((*ctx)[i]) << 5);
        (*ctx)[i] = (((*ctx)[i]) >> 3) | shift_temp;
        shift_temp = c2;
    }

    (*ctx)[35] = 0xE0;
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_init] Warming up cipher (4*288 rounds)" << std::endl;
    }
    
    for(i = 0; i < 4 * 288; ++i) {
        trivium_enc(ctx);
    }
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG trivium_init] Initialization complete" << std::endl;
    }
}

uint8_t trivium_key[10] = {
        0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00
    };
    
uint8_t trivium_iv[10] = {
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00
};
trivium_ctx_t ctx;


std::bitset<MAX_SIZE> stream_cipher_TRIVIUM(std::bitset<MAX_SIZE> input, int n, int /*m*/) {
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Starting cipher with n=" << n 
                  << ", MAX_SIZE=" << MAX_SIZE << std::endl;
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Input bits: " << input.to_string() << std::endl;
    }   
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Using default trivium_key and trivium_IV" << std::endl;
    }
    
    std::bitset<MAX_SIZE> output;
    size_t nsize = static_cast<size_t>(n); 
    size_t bits_to_process = nsize < MAX_SIZE ? nsize : MAX_SIZE;
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Will process " << bits_to_process 
                  << " bits of input" << std::endl;
    }
    
    for (size_t i = 0; i < bits_to_process; i += 8) {
        uint8_t keystream_byte = trivium_getbyte(&ctx);
        
        if(trivium_is_debug_mode) {
            std::cout << "[DEBUG stream_cipher_TRIVIUM] Generated keystream byte at position " << i 
                      << ": " << std::hex << (int)keystream_byte << std::dec << std::endl;
        }
        
        size_t bits_in_this_byte = std::min(static_cast<size_t>(8), bits_to_process - i);
        
        for (size_t j = 0; j < bits_in_this_byte; ++j) {
            bool input_bit = input.test(i + j);
            bool keystream_bit = (keystream_byte >> (7 - j)) & 1;
            output.set(i + j, input_bit ^ keystream_bit);
            
            if(trivium_is_debug_mode && j < 4) { // Limit debug output for first few bits
                std::cout << "[DEBUG stream_cipher_TRIVIUM] Bit " << (i + j) 
                          << ": input=" << input_bit 
                          << ", keystream=" << keystream_bit 
                          << ", output=" << (input_bit ^ keystream_bit) << std::endl;
            }
        }
    }
    
    if(trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Final output bits: " 
                  << output.to_string() << std::endl;
    }
    
    return output;
}


std::vector<char> stream_cipher_TRIVIUM_BYTES(const std::vector<char>& input, int n) {
    if (trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Starting cipher with n=" << n 
                  << ", input size=" << input.size() << std::endl;
    }
    
    
    std::vector<char> output;
    size_t bytes_to_process = static_cast<size_t>(n) / CHAR_BIT;
    bytes_to_process = std::min(bytes_to_process, input.size());
    output.reserve(bytes_to_process + 1); 
    
    if (trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Will process " << bytes_to_process 
                  << " bytes of input" << std::endl;
    }
    
    for (size_t i = 0; i < bytes_to_process; ++i) {
        uint8_t keystream_byte = trivium_getbyte(&ctx);
        uint8_t input_byte = static_cast<uint8_t>(input[i]);
        uint8_t output_byte = input_byte ^ keystream_byte;
        
        output.push_back(static_cast<char>(output_byte));
        
        if (trivium_is_debug_mode && i < 4) {  // Limitar salida de depuración para los primeros bytes
            std::cout << "[DEBUG stream_cipher_TRIVIUM] Byte " << i 
                      << ": input=" << std::hex << static_cast<int>(input_byte)
                      << ", keystream=" << static_cast<int>(keystream_byte)
                      << ", output=" << static_cast<int>(output_byte) << std::dec << std::endl;
        }
    }
    
    // Procesar bits restantes si n no es múltiplo de 8
    size_t remaining_bits = static_cast<size_t>(n) % CHAR_BIT;
    if (remaining_bits > 0 && bytes_to_process < input.size()) {
        uint8_t keystream_byte = trivium_getbyte(&ctx);
        uint8_t input_byte = static_cast<uint8_t>(input[bytes_to_process]);
        uint8_t mask = 0xFF << (CHAR_BIT - remaining_bits);
        uint8_t output_byte = (input_byte ^ keystream_byte) & mask;
        
        // Preservar los bits no procesados del byte de entrada
        output_byte |= (input_byte & ~mask);
        
        output.push_back(static_cast<char>(output_byte));
        
        if (trivium_is_debug_mode) {
            std::cout << "[DEBUG stream_cipher_TRIVIUM] Partial byte " << bytes_to_process 
                      << ": input=" << std::hex << static_cast<int>(input_byte)
                      << ", keystream=" << static_cast<int>(keystream_byte)
                      << ", output=" << static_cast<int>(output_byte) << std::dec << std::endl;
        }
    }
    
    if (trivium_is_debug_mode) {
        std::cout << "[DEBUG stream_cipher_TRIVIUM] Final output size: " 
                  << output.size() << " bytes" << std::endl;
    }
    
    return output;
}

#endif